# report the correct aligned bases, correct aligned sequence number and  errors for SAM format by different methods
# example: python  ligned_statistic_sam_format_simulated_base2base.py -p 0.9 -w 5 -i aligned.sam -m sequence.maf
import sys

import os, argparse

if __name__ == "__main__":
    usage = '''  Mapped acuracy for a sam file simulated by PBSIM.
  Usage example:
  python ''' + sys.argv[0] + ' -i aligned.sam -m pbsim.maf'

    parser = argparse.ArgumentParser(description = usage, formatter_class=argparse.RawTextHelpFormatter)
    parser.add_argument('-i', '--input',   type = str, required = True, help = 'Input sam file [required]')
    parser.add_argument('-m', '--maf',     type = str, required = True, help = 'The .maf file generated by pbsim [required]')
    parser.add_argument('-a', '--all',     type = int, default = 1, help = 'calculate all mapped records [1]')
    parser.add_argument('-p', '--overlap', type = float, default = 0.9, help = 'The overlap percentage [0.9]')
    parser.add_argument('-w', '--width',   type = int, default = 5, help = 'Mapped base position within w bp of the truth position [5]')
    args = parser.parse_args()
    aligned_file = args.input
    maf_file     = args.maf
    w = args.width
    p = args.overlap
    all = args.all
    print()
    if not os.path.exists(aligned_file):
        print(' %s does not exist!' % aligned_file)
        sys.exit(1)
    if not os.path.exists(maf_file):
        print(' %s does not exist!' % maf_file)
        sys.exit(1)
    s = -1
    ii= -2
    d = -2
    base_wise = {} # record the base wise accurate
    overlap_true = {}
    seq_heads_and_len = {}
    total_bases = 0
    maf = open(maf_file)
    ll = maf.readline().strip()
    ll_num = 0
    zz = 0
    aligned_check = {} # store if the read is correctly mapped or not
    while ll:
        ll = ll.strip()
        ll_num +=1
        if ll_num % 4 == 2:
            base_wise_pos = []
            aa = ll.split()
            ll = maf.readline().strip()
            ll_num +=1
            bb = ll.split()
            pos = int(aa[2]) + 1
            pos_1 = pos
            sub_genome = aa[6]
            sub_len = int(aa[3])
            name = bb[1]
            aligned_check[name] = 0 # default all read = 0: not mapped
            seq_len = int(bb[5])
            total_bases += seq_len
            seq_heads_and_len[name] = seq_len
            aligned = bb[6]
            for i in range(len(aligned)):
                if sub_genome[i] == '-':
                    base_wise_pos.append(pos - 1)
                elif aligned[i] == '-':
                    pos += 1
                else:
                    base_wise_pos.append(pos)
                    pos += 1
            if seq_len != len(base_wise_pos):
                print("*** base_wise_pos length not equal to read length, exit!")
                sys.exit(1)
            overlap = range(pos_1, pos_1 + sub_len)
            overlap_true[name] = overlap
            base_wise[name] = base_wise_pos
            zz += 1
            sys.stdout.write(" Reading the %d-th simulated read\r" % zz)
            sys.stdout.flush()
            #print("Sequence num: %d" % zz)
        ll = maf.readline()
    print() 
    total_sequences = zz
    maf.close()
    base_wise_method = {}
    overlap_method = {}
    base_wise_method_start_end = {}
    ff = open(aligned_file)
    line = ff.readline()
    lengthIs = 0
    aligned_seq_header = []
    base_accurate = 0# store the accurate aligned bases number
    aligned_seq_num = 0
    coverage = []
    while line:
        line = line.strip()
        if line.startswith("@"):
            line = ff.readline()
            continue
        aa = line.split()
        if aa[2] == '*':
            line = ff.readline()
            continue
        seq_header = aa[0]
        aligned_is = aa[5]
        start_pos = int(aa[3])
        if all == 0 and seq_header in aligned_seq_header: # just report the first aligned results
            line = ff.readline()
            continue
        aligned_seq_header.append(seq_header)
        if all == 1 and aligned_check[seq_header] == 1: # all mapped records
            line = ff.readline()
            continue
        #aligned_sequence_numm += 1
        if aligned_is == "*":
            line = ff.readline()
            continue
        hhhhh = []
        poss = []
        # strip the S por H at the first and end position
        kai_shi = 0
        pos_start = 0
        for i in range(0, len(aligned_is)):
            if aligned_is[i].isdigit():
                continue
            elif aligned_is[i] == 'M' or aligned_is[i] == '=' or aligned_is[i] == 'X':
                break
            elif aligned_is[i] == 'S' or aligned_is[i] == 'H':
                kai_shi = i + 1
                break
        if kai_shi > 0:
            pos_start = int(aligned_is[0:kai_shi - 1])
        else:
            pos_start = 0
        poss.append(pos_start)
        jie_shu = len(aligned_is)
        if aligned_is[jie_shu - 1] == 'S' or aligned_is[jie_shu - 1] == 'H':
            jie_shu = len(aligned_is) - 1		
        pos_end = pos_start
        startt = kai_shi
        for i in range(kai_shi, jie_shu):
            if aligned_is[i].isdigit():
                continue
            if aligned_is[i] == 'M' or aligned_is[i] == '=' or aligned_is[i] == 'X':
                m_num = int(aligned_is[startt:i])
                startt = i + 1
                pos_end += m_num
                for j in range(m_num):
                    hhhhh.append(start_pos)
                    start_pos += 1
            elif aligned_is[i] == 'I':
                I_num = int(aligned_is[startt:i])
                startt = i + 1
                pos_end += I_num
                for j in range(I_num):
                    hhhhh.append(start_pos)
            elif aligned_is[i] == 'D':
                D_num = int(aligned_is[startt:i])
                startt = i + 1
                for j in range(D_num):
                    start_pos += 1
            else:
                print("invalid letter detelected: %s" % aligned_is[i])
                sys.exit(0)
        poss.append(pos_end - 1)
        base_wise_method[seq_header] = hhhhh
        base_wise_method_start_end[seq_header] = poss
        seq_len = seq_heads_and_len[seq_header]
        overlap = range(hhhhh[0], hhhhh[-1] + 1)
        overlap_method[seq_header] = overlap
        set_g = set(overlap_true[seq_header])
        set_r = set(overlap)
        set_inter = set_g & set_r
        bili = 1.0*len(set_inter)/len(set_g)
        if bili >= p:# bigger than overlap
            bw_true = base_wise[seq_header]
            nn = 0
            for k in range(pos_start, pos_end):
                right = bw_true[k]
                method = hhhhh[nn]
                if abs(right - method) <= w:
                    base_accurate += 1
                nn += 1
            aligned_seq_num += 1
            aligned_check[seq_header] = 1
            aligned_coverage_one = 1.0*(pos_end - pos_start)/seq_len
            coverage.append(aligned_coverage_one)
            sys.stdout.write('Accurate aligned Number: %d \r' % aligned_seq_num)
            sys.stdout.flush()
        line = ff.readline()
    ff.close()
    print('\n')
    print("Total reads:            %d" % total_sequences)
    print("Accurate aligned sequences: %d, %f" % (aligned_seq_num, aligned_seq_num / total_sequences))
    print("Total bases:                %d" % total_bases)
    print("Accurate aligned bases:     %d, %f" % (base_accurate, base_accurate / total_bases))
    #print("Average coverage:           %f" % (sum(coverage)/aligned_seq_num))
    #print("Min coverage:               %f" % min(coverage))

