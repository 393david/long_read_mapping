# Extract the simulated reads that recover the translocation region
# 
import os, sys, argparse
from Bio.Seq import Seq
import numpy as np

if __name__ == "__main__":
    usage = ''' Extract the simulated reads that recover the translocation inversions.

  Usage example:
  python ''' + sys.argv[0] + ' -m1 chr1.maf -m2 chr2.maf -b inversion.bed -o output.fa -o2 output.groundtruth'

    parser = argparse.ArgumentParser(description = usage, formatter_class=argparse.RawTextHelpFormatter)
    parser.add_argument('-m1', '--maf1', type = str, required = True, help = 'Input the simulated.maf file for first genome [required]')
    parser.add_argument('-m2', '--maf2', type = str, required = True, help = 'Input the simulated.maf file for second genome [required]')
    parser.add_argument('-b', '--bed', type = str, required = True, help = 'The .bed file generated by SURVIVOR [required]')
    parser.add_argument('-o', '--output', type = str, required = True, help = 'The output read file [required]')
    parser.add_argument('-o2', '--output2', type = str, required = True, help = 'The output file contained the output reads information[required]')
    parser.add_argument('-p', '--overlap', type = float, default = 1.0, help = 'The overlap ration that reads cover inversion [1.0]')
    args = parser.parse_args()
    p    = args.overlap
    maf  = args.maf1
    maf2 = args.maf2
    bed  = args.bed
    outt = args.output
    outt2= args.output2 
    if not os.path.exists(maf):
        print(' %s does not exist!' % maf)
        sys.exit(1)
    if not os.path.exists(bed):
        print(' %s does not exist!' % bed)
        sys.exit(1)
    if p < 0.0 or p > 1.0:
        print('p = %f, p should 0 < p <= 1' % p)
        sys.exit(1)
    bed_pos_start1 = []
    bed_pos_end1   = []
    bed_length    = []
    bed_set1 = []
    bed_pos_start2 = []
    bed_pos_end2 = []
    bed_set2 = []
    column1 = []
    column2 = []
    n1 = 0
    ff = open(bed)
    line = ff.readline()
    cc = line.split()
    chr1 = cc[0]
    chr2 = cc[2]
    while line:
        line = line.strip()
        aa = line.split()
        line = ff.readline().strip()
        aa2 = line.split()
        if aa[0] == chr1:
            bed_pos_start1.append(int(aa[1]))
            bed_pos_end1.append(int(aa2[1]))
            bed_set1.append(set(range(int(aa[1]), int(aa2[1]))))
            bed_pos_start2.append(int(aa[3]))
            bed_pos_end2.append(int(aa2[3]))
            bed_set2.append(set(range(int(aa[3]), int(aa2[3]))))
        else:
            bed_pos_start1.append(int(aa[3]))
            bed_pos_end1.append(int(aa2[3]))
            bed_set1.append(set(range(int(aa[3]), int(aa2[3]))))
            bed_pos_start2.append(int(aa[1]))
            bed_pos_end2.append(int(aa2[1]))
            bed_set2.append(set(range(int(aa[1]), int(aa2[1]))))
        n1 += 1
        #sys.stdout.write("Inversion in bed file: %d   \r" % n1)
        #sys.stdout.flush()
        line = ff.readline()
    ff.close()
    print()
    print('Translocation in bed file: %d' % n1)
    num2 = 0
    seq_header = []
    seq_is     = []
    covered_inversion = []
    oo  = open(outt, 'w')
    oo2 = open(outt2, 'w')
    ff2 = open(maf)
    line = ff2.readline()
    ll = 0
    covered_num = 0
    index_sorted1 = np.argsort(bed_pos_start1)
    index_sorted2 = np.argsort(bed_pos_start2)
    oo2.write('# The start and end positions both are contained: such as [2, 50]\n')
    oo2.write('Header\tLength\tStrand\tRef_name\tRef_start\tRef_end\tTran_ref_name\tTran_start\tTran_end\tTran_length\n')
    while line:
        ll += 1
        if ll % 4 == 1:
            num2 += 1
            ref_line = ff2.readline().strip()
            rr = ref_line.split()
            pos_start = int(rr[2])
            pos_end   = int(rr[2]) + int(rr[3])
            set_now = set(range(pos_start , pos_end))
            seq_line = ff2.readline().strip().split()
            if rr[4] == seq_line[4]:
                strandd = '+'
            else:
                strandd = '-'
            for i in range(len(index_sorted1)):
                indexx = index_sorted1[i]
                if pos_start >= bed_pos_end1[indexx] or pos_end <= bed_pos_start1[indexx]:
                    continue
                set_tran =  bed_set1[indexx]
                intersection = set_now & set_tran
                lenn = len(intersection)
                if lenn * 1.0 / len(set_tran) >= p:
                    covered_num += 1
                    oo.write('>' + seq_line[1] + '\n')
                    seq_is = seq_line[6].replace('-', '')
                    if strandd == '+':
                        oo.write(seq_is + '\n')
                    else:
                        my_seq = Seq(seq_is)
                        oo.write(str(my_seq.reverse_complement()) + '\n')
                    oo2.write(seq_line[1] + '\t' + seq_line[3] + '\t' + strandd + '\t' + chr1 + '\t' + rr[2] + '\t' + str(pos_end - 1) + '\t' + chr2 + '\t' + str(bed_pos_start2[indexx]) + '\t' + str(bed_pos_end2[indexx] - 1) + '\t' + str(bed_pos_end2[indexx] - bed_pos_start2[indexx]) + '\n')
                    #seq_header.append(seq_line[1] + '_' + strandd + '_' + )
                    #seq_is.append(seq_line[6].replace('-', ''))
                    break
            line = ff2.readline()
            ll += 3
            sys.stdout.write("Reading the %d -th reads in first .maf file, extracted number: %d   \r" % (num2, covered_num))
            sys.stdout.flush()
        line = ff2.readline()
    ff2.close()
    print()
    ff2 = open(maf2)
    line = ff2.readline()
    ll = 0
    num3 = 0
    while line:
        ll += 1
        if ll % 4 == 1:
            num3 += 1
            ref_line = ff2.readline().strip()
            rr = ref_line.split()
            pos_start = int(rr[2])
            pos_end   = int(rr[2]) + int(rr[3])
            set_now = set(range(pos_start , pos_end))
            seq_line = ff2.readline().strip().split()
            if rr[4] == seq_line[4]:
                strandd = '+'
            else:
                strandd = '-'
            for i in range(len(index_sorted2)):
                indexx = index_sorted2[i]
                if pos_start >= bed_pos_end2[indexx] or pos_end <= bed_pos_start2[indexx]:
                    continue
                set_tran =  bed_set2[indexx]
                intersection = set_now & set_tran
                lenn = len(intersection)
                if lenn * 1.0 / len(set_tran) >= p:
                    covered_num += 1
                    oo.write('>' + seq_line[1] + '\n')
                    seq_is = seq_line[6].replace('-', '')
                    if strandd == '+':
                        oo.write(seq_is + '\n')
                    else:
                        my_seq = Seq(seq_is)
                        oo.write(str(my_seq.reverse_complement()) + '\n')
                    oo2.write(seq_line[1] + '\t' + seq_line[3] + '\t' + strandd + '\t' + chr2 + '\t' + rr[2] + '\t' + str(pos_end - 1) + '\t' + chr1 + '\t' + str(bed_pos_start1[indexx]) + '\t' + str(bed_pos_end1[indexx] -1) + '\t' + str(bed_pos_end1[indexx] - bed_pos_start1[indexx]) + '\n')
                    #seq_header.append(seq_line[1] + '_' + strandd + '_' + )
                    #seq_is.append(seq_line[6].replace('-', ''))
                    break
            line = ff2.readline()
            ll += 3
            sys.stdout.write("Reading the %d -th reads in the second .maf file, extracted number: %d   \r" % (num3, covered_num))
            sys.stdout.flush()
        line = ff2.readline()
    oo2.close()
    oo.close()
    ff2.close()
    print('\n\n')
    print('Total reads:     %d + %d = %d' % (num2, num3, num2 + num3))
    print('Extracted reads: %d' % covered_num)
    #print('Recordes in SAM1 covered by SAM2: %f' % (num1 * 1.0 / len(aligned_seq_header)))
    #print('Recordes in SAM2 covered by SAM1: %f' % (num2 * 1.0 / len(aligned_seq_header2)))
